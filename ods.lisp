(in-package :clods-export)

(defparameter *ns-table* (namespace "urn:oasis:names:tc:opendocument:xmlns:table:1.0"))
(defparameter *ns-office* (namespace "urn:oasis:names:tc:opendocument:xmlns:office:1.0"))
(defparameter *ns-text* (namespace "urn:oasis:names:tc:opendocument:xmlns:text:1.0"))
(defparameter *ns-style* (namespace "urn:oasis:names:tc:opendocument:xmlns:style:1.0"))
(defparameter *ns-fo* (namespace "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0"))
(defparameter *ns-of* (namespace "urn:oasis:names:tc:opendocument:xmlns:of:1.2"))
(defparameter *ns-xlink* (namespace "http://www.w3.org/1999/xlink"))
(defparameter *ns-number* (namespace "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0"))
(defparameter *ns-svg* (namespace "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0"))
(defparameter *ns-meta* (namespace "urn:oasis:names:tc:opendocument:xmlns:meta:1.0"))
(defparameter *ns-dc* (namespace "http://purl.org/dc/elements/1.1/"))

(defun add-ods-namespaces ()
  (attr (*xmlns* "table") *ns-table*)
  (attr (*xmlns* "office") *ns-office*)
  (attr (*xmlns* "text") *ns-text*)
  (attr (*xmlns* "style") *ns-style*)
  (attr (*xmlns* "fo") *ns-fo*)
  (attr (*xmlns* "of") *ns-of*)
  (attr (*xmlns* "xlink") *ns-xlink*)
  (attr (*xmlns* "number") *ns-number*)
  (attr (*xmlns* "svg") *ns-svg*))

(defun make-ods-styles ()
  (cl-fad:with-output-to-temporary-file (str)
    (writing-xml (str :standalone t)
      (with-tag ((*ns-office* "document-styles"))
	(add-ods-namespaces)
	(attr (*ns-office* "version") "1.2")))))

(defun make-ods-content (str)
  (writing-xml (str :standalone t)
    (with-tag ((*ns-office* "document-content"))
      (add-ods-namespaces)
      (attr (*ns-office* "version") "1.2")
      (with-tag ((*ns-office* "font-face-decls")))
      (with-tag ((*ns-office* "automatic-styles")))
      (with-tag ((*ns-office* "body"))
	(with-tag ((*ns-office* "spreadsheet"))
	  (with-tag ((*ns-table* "table"))
	    (attr (*ns-table* "name") "Vuokrasopimukset")
	    (with-tag ((*ns-table* "table-column"))
	      (attr (*ns-table* "number-columns-repeated") "4"))
	    (with-tag ((*ns-table* "table-row"))
	      (with-tag ((*ns-table* "table-cell"))
		(attr (*ns-office* "value-type") "string")
		(tag (*ns-text* "p") "Vuokanantaja"))
	      (with-tag ((*ns-table* "table-cell"))
		(attr (*ns-office* "value-type") "string")
		(tag (*ns-text* "p") "Tilan numero"))
	      (with-tag ((*ns-table* "table-cell"))
		(attr (*ns-office* "value-type") "string")
		(tag (*ns-text* "p") "Pinta-ala"))
	      (with-tag ((*ns-table* "table-cell"))
		(attr (*ns-office* "value-type") "string")
		(tag (*ns-text* "p") "Päiväys"))))
	  (with-tag ((*ns-table* "table"))
	    (attr (*ns-table* "name") "Jäsenluettelo")
	    (with-tag ((*ns-table* "table-column"))
	      (attr (*ns-table* "number-columns-repeated") "4"))
	    (with-tag ((*ns-table* "table-row"))
	      (with-tag ((*ns-table* "table-cell"))
		(attr (*ns-office* "value-type") "string")
		(tag (*ns-text* "p") "Vuokanantaja"))
	      (with-tag ((*ns-table* "table-cell"))
		(attr (*ns-office* "value-type") "string")
		(tag (*ns-text* "p") "Tilan numero"))
	      (with-tag ((*ns-table* "table-cell"))
		(attr (*ns-office* "value-type") "string")
		(tag (*ns-text* "p") "Pinta-ala"))
	      (with-tag ((*ns-table* "table-cell"))
		(attr (*ns-office* "value-type") "string")
		(tag (*ns-text* "p") "Päiväys")))))))))

(defun make-ods-manifest ()
  (cl-fad:with-output-to-temporary-file (str)
    (let ((mfns (namespace "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")))
      (writing-xml (str :standalone t)
	(with-tag ((mfns "manifest"))
	  (attr (*xmlns* "manifest") mfns)
	  (with-tag ((mfns "file-entry"))
	    (attr (mfns "full-path") "/")
	    (attr (mfns "media-type") "application/vnd.oasis.opendocument.spreadsheet"))
	  (with-tag ((mfns "file-entry"))
	    (attr (mfns "full-path") "styles.xml")
	    (attr (mfns "media-type") "text/xml"))
	  (with-tag ((mfns "file-entry"))
	    (attr (mfns "full-path") "content.xml")
	    (attr (mfns "media-type") "text/xml"))
	  (with-tag ((mfns "file-entry"))
	    (attr (mfns "full-path") "meta.xml")
	    (attr (mfns "media-type") "text/xml")))))))

(defun make-ods-meta (generator creator)
  (cl-fad:with-output-to-temporary-file (str)
    (let ((date (multiple-value-bind (sec min hour day month year)
		    (decode-universal-time (get-universal-time) 0)
		  (format nil "~4,'0d-~2,'0d-~2,'0dT~2,'0d:~2,'0d:~2,'0dZ"
			  year month day hour min sec))))
      (writing-xml (str :standalone t)
	(with-tag ((*ns-office* "document-meta"))
	  (attr (*xmlns* "office") *ns-office*)
	  (attr (*xmlns* "meta") *ns-meta*)
	  (attr (*xmlns* "dc") *ns-dc*)
	  (attr (*xmlns* "xlink") *ns-xlink*)
	  (attr (*ns-office* "version") "1.2")
	  (with-tag ((*ns-office* "meta"))
	    (tag (*ns-meta* "generator") generator)
	    (tag (*ns-meta* "initial-creator") creator)
	    (tag (*ns-dc* "creator") creator)
	    (tag (*ns-meta* "creation-date") date)
	    (tag (*ns-dc* "date") date)))))))

(defun make-ods-mimetype ()
  (cl-fad:with-output-to-temporary-file (str)
    (write-string "application/vnd.oasis.opendocument.spreadsheet" str)))

(defun export-to-ods (file)
  (let (mimetype styles content manifest meta)
    (unwind-protect
	 (progn
	   (setq mimetype (cl-fad:with-output-to-temporary-file (f)
			    (write-string "application/vnd.oasis.opendocument.spreadsheet" f))
		 styles (cl-fad:with-output-to-temporary-file (f) (make-ods-styles f))
		 content (cl-fad:with-output-to-temporary-file (f) (make-ods-content f))
		 manifest (cl-fad:with-output-to-temporary-file (f) (make-ods-manifest f))
		 meta (cl-fad:with-output-to-temporary-file (f) (make-ods-meta f)))

	   (zip:with-output-to-zipfile (zip file :if-exists :supersede)
	     (flet ((add-file (name path)
		      (with-open-file (f path :direction :input :element-type '(unsigned-byte 8))
			(zip:write-zipentry zip name f))))
	       (add-file "mimetype" mimetype)
	       (add-file "styles.xml" styles)
	       (add-file "content.xml" content)
	       (add-file "META-INF/manifest.xml" manifest)
	       (add-file "meta.xml" meta))))
      (when mimetype (delete-file mimetype))
      (when styles (delete-file styles))
      (when content (delete-file content))
      (when manifest (delete-file manifest))
      (when meta (delete-file meta)))))

(defun zip-ods (out files)
  (zip:with-output-to-zipfile (zip out :if-exists :supersede)
    (dolist (file files)
      (with-open-file (f (cdr file) :direction :input :element-type '(unsigned-byte 8))
	(zip:write-zipentry zip (car file) f)))))

(defun kw-to-string (kw &optional allowed)
  (check-type kw keyword)
  (cond ((and allowed (listp (first allowed)))
	 (let ((match (find kw allowed :key #'first)))
	   (unless match
	     (error 'type-error :expected-type (cons 'member (mapcar #'first allowed)) :datum kw))
	   (second match)))
	((or (null allowed)
	     (find kw allowed))
	 (string-downcase kw))
	(t
	 (error 'type-error :expected-type (cons 'member allowed) :datum kw))))

(defvar *sheet-state* nil)

(export 'with-spreadsheet)
(defmacro with-spreadsheet ((file &key (generator "clods") (creator "clods")) &body body)
  (alexandria:with-gensyms (zip-files i str)
    `(let (,zip-files)
       (unwind-protect
	    (progn
	      (push (cons "content.xml"
			  (cl-fad:with-output-to-temporary-file (,str)
			    (writing-xml (,str :standalone t)
			      (with-tag ((*ns-office* "document-content"))
				(add-ods-namespaces)
				(attr (*ns-office* "version") "1.2")
				(let ((*sheet-state* :start))
				  ,@body
				  (unless (eq *sheet-state* :end)
				    (error "no data on spreadsheet - a with-body form is required")))
				#+ignore
				(with-tag ((*ns-office* "body"))
				  (with-tag ((*ns-office* "spreadsheet"))
				    (with-tag ((*ns-table* "table"))
				      (attr (*ns-table* "name") "Vuokrasopimukset")
				      (with-tag ((*ns-table* "table-column"))
					(attr (*ns-table* "number-columns-repeated") "4"))
				      (with-tag ((*ns-table* "table-row"))
					(with-tag ((*ns-table* "table-cell"))
					  (attr (*ns-office* "value-type") "string")
					  (tag (*ns-text* "p") "Vuokanantaja"))
					(with-tag ((*ns-table* "table-cell"))
					  (attr (*ns-office* "value-type") "string")
					  (tag (*ns-text* "p") "Tilan numero"))
					(with-tag ((*ns-table* "table-cell"))
					  (attr (*ns-office* "value-type") "string")
					  (tag (*ns-text* "p") "Pinta-ala"))
					(with-tag ((*ns-table* "table-cell"))
					  (attr (*ns-office* "value-type") "string")
					  (tag (*ns-text* "p") "Päiväys"))))
				    (with-tag ((*ns-table* "table"))
				      (attr (*ns-table* "name") "Jäsenluettelo")
				      (with-tag ((*ns-table* "table-column"))
					(attr (*ns-table* "number-columns-repeated") "4"))
				      (with-tag ((*ns-table* "table-row"))
					(with-tag ((*ns-table* "table-cell"))
					  (attr (*ns-office* "value-type") "string")
					  (tag (*ns-text* "p") "Vuokanantaja"))
					(with-tag ((*ns-table* "table-cell"))
					  (attr (*ns-office* "value-type") "string")
					  (tag (*ns-text* "p") "Tilan numero"))
					(with-tag ((*ns-table* "table-cell"))
					  (attr (*ns-office* "value-type") "string")
					  (tag (*ns-text* "p") "Pinta-ala"))
					(with-tag ((*ns-table* "table-cell"))
					  (attr (*ns-office* "value-type") "string")
					  (tag (*ns-text* "p") "Päiväys"))))))))))
		    ,zip-files)
	      (push (cons "styles.xml" (make-ods-styles)) ,zip-files)
	      (push (cons "meta.xml" (make-ods-meta ,generator ,creator)) ,zip-files)
	      (push (cons "META-INF/manifest.xml" (make-ods-manifest)) ,zip-files)
	      (push (cons "mimetype" (make-ods-mimetype)) ,zip-files)
	      (zip-ods ,file ,zip-files))
	 (dolist (,i ,zip-files)
	   (delete-file (cdr ,i)))))))

(export 'with-fonts)
(defmacro with-fonts (() &body body)
  `(progn
     (unless (eq *sheet-state* :start)
       (error "with-fonts must appear as the first child of with-spreadsheet form"))
     (with-tag ((*ns-office* "font-face-decls"))
       (let ((*sheet-state* :with-fonts))
	 ,@body))
     (setf *sheet-state* :fonts-defined)))

(export 'font)
(defun font (name &key family style weight size variant stretch)
  (unless (eq *sheet-state* :with-fonts)
    (error "font must be called in the context of a with-fonts form"))
  (with-tag ((*ns-style* "font-face"))
    (attr (*ns-style* "name") name)
    (when family (attr (*ns-svg* "font-family") family))
    (when style (attr (*ns-svg* "font-style") (kw-to-string style '(:normal :italic :oblique))))
    (when weight (attr (*ns-svg* "font-weight")
		       (if (numberp weight)
			   (princ-to-string weight)
			   (kw-to-string weight '(:normal :bold :bolder :lighter)))))
    (when variant (attr (*ns-svg* "font-variant") (kw-to-string variant '(:normal :small-caps))))
    (when size (attr (*ns-svg* "font-size")
		     (if (stringp size)
			 size
			 (kw-to-string size '(:xx-small :x-small :small :medium :large :x-large :xx-large
					      :larger :smaller)))))
    (when stretch (attr (*ns-svg* "font-stretch")
			(kw-to-string stretch '(:ultra-condensed :extra-condensed :condensed :semi-condensed
						:normal
						:semi-expanded :expanded :extra-expanded :ultra-expanded))))))

(export 'with-styles)
(defmacro with-styles (() &body body)
  `(progn
     (unless (or (eq *sheet-state* :start) (eq *sheet-state* :fonts-defined))
       (error "with-styles must appear as a child of a with-spreadsheet form, in the beginning or just after a with-fonts form"))
     (with-tag ((*ns-office* "automatic-styles"))
       (let ((*sheet-state* :automatic-styles))
	 ,@body)
       (setf *sheet-state* :styles-defined))))

(defun ensure-style-state ()
  (unless (eq *sheet-state* :automatic-styles)
    (error "styles can only be defined inside a with-styles form")))

(defun valid-color (c)
  (and (stringp c)
       (= (length c) 7)
       (char= #\# (char c 0))
       (ignore-errors (parse-integer c :start 1 :radix 16))
       t))

(defparameter *line-types* '(:none :single :double))
(defparameter *line-styles* '(:none :solid :dotted :dash :long-dash :dot-dash :dot-dot-dash :wave))
(defparameter *line-widths* '(:auto :normal :bold :thin :medium :thick))

(defparameter *text-properties*
  (list (list :font-variant *ns-fo* '(:normal :small-caps))
	(list :text-transform *ns-fo* '(:none :lowercase :uppercase :capitalize))
	(list :color *ns-fo* #'valid-color)
	(list :use-window-font-color *ns-style* 'boolean)
	(list :text-outline *ns-style* 'boolean)
	(list :text-line-through-type *ns-style* *line-types*)
	(list :text-line-through-style *ns-style* *line-styles*)
	(list :text-line-through-width *ns-style* *line-widths*)
	(list :text-line-through-color *ns-style* #'(lambda (x) (or (eq x :font-color) (valid-color x))))
	(list :text-line-through-mode *ns-style* '(:continuous :skip-white-space))
	(list :text-line-through-text *ns-style* 'string)
	(list :text-line-through-text-style *ns-style* 'string)
	(list :text-position *ns-style* '(:super :sub))
	(list :font-name *ns-style* 'string)
	(list :font-name-asian *ns-style* 'string)
	(list :font-name-complex *ns-style* 'string)
	(list :font-family *ns-style* 'string)
	(list :font-family-asian *ns-style* 'string)
	(list :font-family-complex *ns-style* 'string)
	(list :font-family-generic *ns-style* '(:roman :swiss :modern :decorative :script :system))
	(list :font-family-generic-asian *ns-style* '(:roman :swiss :modern :decorative :script :system))
	(list :font-family-generic-complex *ns-style* '(:roman :swiss :modern :decorative :script :system))
	(list :font-style-name *ns-style* 'string)
	(list :font-style-name-asian *ns-style* 'string)
	(list :font-style-name-complex *ns-style* 'string)
	(list :font-pitch *ns-style* '(:fixed :variable))
	(list :font-pitch-asian *ns-style* '(:fixed :variable))
	(list :font-pitch-complex *ns-style* '(:fixed :variable))
	(list :font-size *ns-fo* 'string)
	(list :font-size-asian *ns-style* 'string)
	(list :font-size-complex *ns-style* 'string)
	(list :font-size-rel *ns-style* 'string)
	(list :font-size-rel-asian *ns-style* 'string)
	(list :font-size-rel-complex *ns-style* 'string)
	(list :script-type *ns-style* '(:latin :asian :complex :ignore))
	(list :letter-spacing *ns-fo* 'string)
	(list :font-style *ns-fo* '(:normal :italic :oblique))
	(list :font-style-asian *ns-style* '(:normal :italic :oblique))
	(list :font-style-complex *ns-style* '(:normal :italic :oblique))
	(list :font-relief *ns-style* '(:none :embossed :engraved))
	(list :text-shadow *ns-fo* 'string)
	(list :text-underline-type *ns-style* *line-types*)
	(list :text-underline-style *ns-style* *line-styles*)
	(list :text-underline-width *ns-style* *line-widths*)
	(list :text-underline-color *ns-style* #'(lambda (x) (or (eq x :font-color) (valid-color x))))
	(list :text-underline-mode *ns-style* '(:continuous :skip-white-space))
	(list :text-overline-type *ns-style* *line-types*)
	(list :text-overline-style *ns-style* *line-styles*)
	(list :text-overline-width *ns-style* *line-widths*)
	(list :text-overline-color *ns-style* #'(lambda (x) (or (eq x :font-color) (valid-color x))))
	(list :text-overline-mode *ns-style* '(:continuous :skip-white-space))
	(list :font-weight *ns-fo* '(:normal :bold 100 200 300 400 500 600 700 800 900))
	(list :font-weight-asian *ns-style* '(:normal :bold 100 200 300 400 500 600 700 800 900))
	(list :font-weight-complex *ns-style* '(:normal :bold 100 200 300 400 500 600 700 800 900))
	(list :letter-kerning *ns-style* 'boolean)
	(list :text-blinking *ns-style* 'boolean)
	(list :text-combine *ns-style* '(:none :letters :lines))
	(list :text-emphasize *ns-style* '((:none :accent :dot :circle :disc) (:above :below)))
	(list :text-scale *ns-style* 'string)
	(list :text-rotation-angle *ns-style* 'string)
	(list :text-rotation-scale *ns-style* '(:fixed :line-height))
	(list :hyphenate *ns-fo* 'boolean)
	(list :hyphenation-remain-char-count *ns-fo* 'integer)
	(list :hyphenation-push-char-count *ns-fo* 'integer)))

(defun write-text-properties (props)
  (flet ((any-value (x)
	   (etypecase x
	     (string x)
	     (symbol (string-downcase x))
	     (number (princ-number x)))))
    (with-tag ((*ns-style* "text-properties"))
      (loop for (kw data) on props by #'cddr
	    for (nil ns constr) = (find kw *text-properties* :key #'first)
	    do (check-type kw keyword)
	    unless ns do (error "unknown text property: ~s" kw)
	    do (attr (ns (string-downcase kw))
		     (cond ((eq 'string constr)
			    (check-type data string)
			    data)
			   ((eq 'integer constr)
			    (check-type data integer)
			    (princ-to-string data))
			   ((eq 'boolean constr)
			    (if data "true" "false"))
			   ((functionp constr)
			    (unless (funcall constr data)
			      #1=(error "invalid value ~s for text property ~s" data kw))
			    (any-value data))
			   ((and (listp constr) (listp (first constr)))
			    (check-type data list)
			    (apply #'concatenate 'string
				   (iter (for i in data)
					 (for c in constr)
					 (unless (find i c)
					   #1#)
					 (unless (eq i (first data))
					   (collect " "))
					 (collect (any-value i)))))
			   ((listp constr)
			    (unless (find data constr)
			      #1#)
			    (any-value data))))))))

(defun princ-number (num)
  (let* ((str (princ-to-string num))
	 (len (length str)))
    (if (and (> len 2)
	     (char= #\D (char-upcase (char str (- len 2))))
	     (char= #\0 (char str (- len 1))))
	(subseq str 0 (- len 2))
	str)))

(defun write-number-number (spec &key (normal-only t))
  (let* (not-normal not-frac not-sci
	 (attrs (loop for (kw data) on spec by #'cddr
		      collect (list kw
				    (ecase kw
				      (:min-integer-digits
				       (check-type data integer)
				       (princ-to-string data))
				      (:decimal-places
				       (check-type data integer)
				       (setf not-frac t)
				       (princ-to-string data))
				      (:decimal-replacement
				       (check-type data string)
				       (setf not-frac t not-sci t)
				       data)
				      (:display-factor
				       (check-type data real)
				       (setf not-frac t not-sci t)
				       (princ-number data))
				      (:number-grouping
				       (if data "true" "false"))
				      (:min-exponent-digits
				       (check-type data integer)
				       (setf not-normal t not-frac t)
				       (princ-to-string data))
				      ((:denominator-value :min-denominator-digits :min-numerator-digits)
				       (check-type data integer)
				       (setf not-normal t not-sci t)
				       (princ-to-string data)))))))
    (with-tag ((*ns-number* (cond ((not not-normal) "number")
				  (normal-only (error "invalid number specification: ~s" spec))
				  ((not not-sci) "scientific-number")
				  ((not not-frac) "fraction")
				  ((error "conflicting number specification: ~s" spec)))))
      (dolist (i attrs)
	(attr (*ns-number* (string-downcase (first i)))
	      (second i))))))

(export 'number-boolean-style)
(defun number-boolean-style (name &key text-properties text text-2)
  (ensure-style-state)
  (with-tag ((*ns-number* "boolean-style"))
    (attr (*ns-style* "name") name)
    (write-text-properties text-properties)
    (when text
      (tag (*ns-number* "text") text))
    (when text-2
      (tag (*ns-number* "boolean"))
      (tag (*ns-number* "text") text-2))))

(export 'number-currency-style)
(defun number-currency-style (name format &key text-properties)
  (ensure-style-state)
  (with-tag ((*ns-number* "currency-style"))
    (attr (*ns-style* "name") name)
    (write-text-properties text-properties)
    (check-type format list)
    (unless (and (evenp (length format))
		 (<= (count :symbol format) 1)
		 (<= (count :text format) 1)
		 (= (count :number format) 1))
      (error "invalid currency style format ~s" format))
    (iter (for (kw data) on format by #'cddr)
	  (ecase kw
	    (:symbol (tag (*ns-number* "currency-symbol") data))
	    (:text (tag (*ns-number* "text") data))
	    (:number (write-number-number data))))))

(defun date-or-time-style (date-p name format text-properties)
  (ensure-style-state)
  (with-tag ((*ns-number* (if date-p "date-style" "time-style")))
    (attr (*ns-style* "name") name)
    (write-text-properties text-properties)
    (dolist (i format)
      (etypecase i
	(string (tag (*ns-number* "text") i))
	(keyword (let* ((sym (symbol-name i))
			(dash (position #\- sym))
			(style (and dash (string-downcase (subseq sym 0 dash))))
			(field (and dash (string-downcase (subseq sym (1+ dash))))))
		   (unless (and dash
				(find style '("long" "short") :test #'string=)
				(or (find field '("hours" "minutes" "seconds" "am-pm"))
				    (and date-p
					 (find field '("day" "month" "year" "era"
						       "day-of-week" "week-of-year" "quarter")))))
		     (error "invalid date/time field: ~s" i))
		   (with-tag ((*ns-number* field)) (attr (*ns-number* "style") style))))))))

(export 'number-date-style)
(defun number-date-style (name format &key text-properties)
  (date-or-time-style t name format text-properties))

(export 'number-time-style)
(defun number-time-style (name format &key text-properties)
  (date-or-time-style nil name format text-properties))

(export 'number-number-style)
(defun number-number-style (name format &key text-properties prefix suffix)
  (ensure-style-state)
  (with-tag ((*ns-number* "number-style"))
    (attr (*ns-style* "name") name)
    (write-text-properties text-properties)
    (when prefix
      (tag (*ns-number* "text") prefix))
    (write-number-number format :normal-only nil)
    (when suffix
      (tag (*ns-number* "text") suffix))))

(export 'number-percentage-style)
(defun number-percentage-style (name format &key text-properties)
  (ensure-style-state)
  (with-tag ((*ns-number* "percentage-style"))
    (attr (*ns-style* "name") name)
    (write-text-properties text-properties)
    (write-number-number format)
    (tag (*ns-number* "text") " %")))

(export 'number-text-style)
(defun number-text-style (name &key text-properties prefix suffix)
  (ensure-style-state)
  (with-tag ((*ns-number* "text-style"))
    (attr (*ns-style* "name") name)
    (write-text-properties text-properties)
    (when prefix
      (tag (*ns-number* "text") prefix))
    (tag (*ns-number* "text-content"))
    (when suffix
      (tag (*ns-number* "text") suffix))))

(defmacro defstyle (name (&rest args) &body body)
  `(defun ,(if (listp name) (first name) name)
       ,(append args '(parent-style next-style data-style percentage-data-style))
     (with-tag ((*ns-style* "style"))
       (attr (*ns-style* "name") name)
       (attr (*ns-style* "family") ,(if (listp name)
					(second name)
					(string-downcase (subseq (symbol-name name) 0 (position #\- (symbol-name name))))))
       (when parent-style
	 (attr (*ns-style* "parent-style-name") parent-style))
       (when next-style
	 (attr (*ns-style* "next-style-name") next-style))
       (when data-style
	 (attr (*ns-style* "data-style-name") data-style))
       (when percentage-data-style
	 (attr (*ns-style* "percentage-data-style-name") percentage-data-style))
       ,@body)))

(export 'text-style)
(defstyle text-style (name text-properties &key)
  (write-text-properties text-properties))

(defun write-background (background)
  (when background
    (attr (*ns-fo* "background-color")
	  (if (eq background :transparent)
	      "transparent"
	      (if (valid-color background)
		  background
		  (error "invalid color specification: ~s" background))))))

(export 'table-style)
(defstyle table-style (name &key width rel-width align background)
  (with-tag ((*ns-style* "table-properties"))
    (when width
      (check-type width string)
      (attr (*ns-style* "width") width))
    (when rel-width
      (check-type rel-width string)
      (attr (*ns-style* "rel-width") rel-width))
    (when align
      (check-type align (member :left :center :right :margins))
      (attr (*ns-table* "align") (string-downcase align)))
    (write-background background)))

(export 'column-style)
(defstyle (column-style "table-column") (name &key width rel-width (use-optimal-width nil opt-width-supplied))
  (with-tag ((*ns-style* "table-column-properties"))
    (when width
      (check-type width string)
      (attr (*ns-style* "column-width") width))
    (when rel-width
      (check-type rel-width string)
      (attr (*ns-style* "rel-column-width") rel-width))
    (when opt-width-supplied
      (attr (*ns-style* "use-optimal-column-width") (if use-optimal-width "true" "false")))))

(export 'row-style)
(defstyle (row-style "table-row") (name &key height min-height (use-optimal-height nil opt-height-supplied) background)
  (with-tag ((*ns-style* "table-row-properties"))
    (when height
      (check-type height string)
      (attr (*ns-style* "row-height") height))
    (when min-height
      (check-type min-height string)
      (attr (*ns-style* "min-row-height") min-height))
    (when opt-height-supplied
      (attr (*ns-style* "use-optimal-row-height") (if use-optimal-height "true" "false")))
    (write-background background)))

(export 'cell-style)
(defstyle (cell-style "table-cell") (name text-properties &key vertical-align text-align-source background
					  border border-left border-top border-right border-bottom
					  (wrap nil wrap-supplied))
  (with-tag ((*ns-style* "table-cell-properties"))
    (when vertical-align
      (check-type vertical-align (member :top :middle :bottom :automatic))
      (attr (*ns-style* "vertical-align") (string-downcase vertical-align)))
    (when text-align-source
      (check-type text-align-source (member :fix :value-type))
      (attr (*ns-style* "text-align-source") (string-downcase text-align-source)))
    (write-background background)
    (flet ((write-border (dir which)
	     (let ((val (or which border)))
	       (when val
		 (check-type val list)
		 (unless (and (= (length val) 3)
			      (find (first val) *line-widths*)
			      (find (second val) *line-styles*)
			      (valid-color (third val)))
		   (error "invalid border definition: ~s" val))
		 (attr (*ns-fo* (format nil "border-~a" dir))
		       (format nil "~a ~a ~a"
			       (string-downcase (first val))
			       (string-downcase (second val))
			       (third val)))))))
      (write-border "left" border-left)
      (write-border "top" border-top)
      (write-border "right" border-right)
      (write-border "bottom" border-bottom))
    (when wrap-supplied
      (attr (*ns-fo* "wrap-option") (if wrap "wrap" "no-wrap"))))
  (when text-properties
    (write-text-properties text-properties)))


(export 'with-body)
(defmacro with-body (() &body body)
  `(progn
     (unless (find *sheet-state* '(:start :fonts-defined :styles-defined))
       (error "with-body must be the last child of a with-spreadsheet form"))
     (with-tag ((*ns-office* "body"))
       (with-tag ((*ns-office* "spreadsheet"))
	 (let ((*sheet-state* :spreadsheet))
	   ,@body
	   (unless (eq *sheet-state* :table-seen)
	     (error "no data on spreadsheet - at least one with-table form is required")))
	 (setf *sheet-state* :end)))))

(export 'with-table)
(defmacro with-table ((name) &body body)
  `(progn
     (unless (find *sheet-state* '(:spreadsheet :table-seen))
       (error "with-table must be a child of a with-body form"))
     ,(unless (typep name 'string)
	`(check-type ,name string))
     (with-tag ((*ns-table* "table"))
       (attr (*ns-table* "name") ,name)
       (tag (*ns-table* "title") ,name)
       (let ((*sheet-state* :table))
	 ,@body)
       (setf *sheet-state* :table-seen))))

(export 'with-header-columns)
(defmacro with-header-columns (() &body body)
  `(with-tag ((*ns-table* "table-header-columns"))
     ,@body))

(defun write-col-row-attrs (repeat style visibility cell-style)
  (when repeat
    (check-type repeat (integer 1 *))
    (attr (*ns-table* "number-columns-repeated") repeat))
  (when style
    (check-type style string)
    (attr (*ns-table* "style-name") style))
  (when visibility
    (check-type visibility (member :visible :collapse :filter))
    (attr (*ns-table* "visibility") (string-downcase visibility)))
  (when cell-style
    (check-type cell-style string)
    (attr (*ns-table* "default-cell-style-name") cell-style)))

(export 'column)
(defun column (&key repeat style visibility cell-style)
  (with-tag ((*ns-table* "table-column"))
    (write-col-row-attrs repeat style visibility cell-style)))

(export 'with-header-rows)
(defmacro with-header-rows (() &body body)
  `(with-tag ((*ns-table* "table-header-rows"))
     ,@body))

(export 'with-row)
(defmacro with-row ((&key repeat style visibility cell-style) &body body)
  `(with-tag ((*ns-table* "table-row"))
     (write-col-row-attrs ,repeat ,style ,visibility ,cell-style)
     ,@body))

(export 'cell)
(defun cell (content &key style formula span-columns span-rows link value-type raw-value)
  (when content
    (check-type content string))
  (with-tag ((*ns-table* "table-cell"))
    (when style
      (check-type style string)
      (attr (*ns-table* "style-name") style))
    (when formula
      (check-type formula string)
      (attr (*ns-table* "formula") formula))
    (when (or content raw-value)
      (when value-type
	(check-type value-type (member :float :percentage :currency :date :time :boolean :string)))
      (attr (*ns-office* "value-type") (if value-type
					   (string-downcase value-type)
					   (typecase (or raw-value content)
					     (real "float")
					     (t "string"))))
      (unless (or (eq value-type :string)
		  (stringp (or raw-value content)))
	(attr (*ns-office* (case (or value-type :float)
			     ((:float :percentage :currency) "value")
			     (:date "date-value")
			     (:time "time-value")
			     (:boolean "boolean-value")))
	      (cond ((realp raw-value)
		     (princ-number raw-value))
		    (raw-value
		     (princ-to-string raw-value))
		    (content)))))
    (when (or span-columns span-rows)
      (check-type span-columns (or null (integer 1 *)))
      (check-type span-rows (or null (integer 1 *)))
      (attr (*ns-table* "number-columns-spanned") (princ-to-string (or span-columns 1)))
      (attr (*ns-table* "number-rows-spanned") (princ-to-string (or span-rows 1))))
    (when content
      (with-tag ((*ns-text* "p") :compact t)
	(if link
	    (with-tag ((*ns-text* "a"))
	      (attr (*ns-xlink* "href") link)
	      (content content))
	    (content content)))))
  (when (and span-columns (> span-columns 1))
    (dotimes (i (1- span-columns))
      (tag (*ns-table* "covered-table-cell"))))
  (when (and span-rows (> span-rows 1))
    (error "span-rows not implemented properly yet")))

(export 'cells)
(defun cells (content &rest options)
  (dolist (i content)
    (apply #'cell i options)))
